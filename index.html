<style>
    body {
        background: black;
    }

    .game {
        position: relative;
    }

    .game-layer {
        position: absolute;
        left: 0;
        top: 0;
    }

    #history_layer {
        background: #111;
    }
</style>

<div class="game">
    <canvas id="history_layer" class="game-layer" width="1024" height="800"></canvas>
    <canvas id="position_layer" class="game-layer" width="1024" height="800"></canvas>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>

<script>
    "use strict";
    // * utils *
    function zeroes(x, y) {
        return new Array(x).fill().map(() => new Array(y).fill(0));
    }

    let get_key_state = (() => {
        let state = {};

        $('body').on('keydown', (e) => {
            state[e.key] = true;
        }).on('keyup', (e) => {
            state[e.key] = false;
        });

        return (key) => state.hasOwnProperty(key) && state[key] || false;
    })();

    let random_direction = () => Math.random() * 2 * Math.PI;
    let random_within = (min, max) => Math.random() * (max-min) + min;
</script>

<script>
    "use strict";

    let History = function (x, y) {
        let grid = zeroes(x, y);

        console.log('width', grid.length);
        console.log('height', grid[0].length);

        this.push = function (x, y) {
            // Checks whether surrounding pixels have been visited and kills
            // the worm with an exception if any of them have. Otherwise pushes
            // the current position to history.
            if (grid[x][y]
                    || grid[x-1][y]
                    || grid[x+1][y]
                    || grid[x][y-1]
                    || grid[x][y+1]) {
                throw Error("you have already been here");
            }
            grid[x][y] = 1;
        };
    };

    let JUMP_LENGTH = 5;

    let Worm = function (x, y, direction, color, history, keys) {
        let _this = this;
        let speed = .14;
        let turn_speed = .04;
        let dead = false;
        let size = 4;
        this.x = x;
        this.y = y;
        this.direction = direction;
        let in_jump = false;
        let jump_count = 0;
        let last_paint_time;
        let previous_x, previous_y;

        let get_x = () => Math.round(this.x);
        let get_y = () => Math.round(this.y);

        let die = () => {
            speed = 0;
            dead = true;
        };

        let pushHistory = () => {
            try {
                history.push(get_x(), get_y());
            } catch (e) {
                // die if we're not in the same position as in the previous loop
                if (previous_x !== get_x() || previous_y !== get_y()) {
                    console.log(e);
                    console.log(color, get_x(), get_y());
                    die();
                }
            }
            previous_x = get_x();
            previous_y = get_y();
        };

        this.start_jump = () => {
            in_jump = true;
            jump_count = 0;
        };

        this.jump = () => {
            jump_count += 1;
            if (jump_count > JUMP_LENGTH)
                in_jump = false;
        };

        this.travel = () => {
            // don't move if we're dead
            if (dead) return;

            if (last_paint_time === undefined)
                last_paint_time = performance.now();

            // if we're in a jump, count the number of loops,
            // otherwise push the position to history
            if (!in_jump) pushHistory();
            else this.jump();

            if (get_key_state(keys.left))
                _this.direction -= turn_speed;
            else if (get_key_state(keys.right))
                _this.direction += turn_speed;

            let paint_time = performance.now();
            let dt = paint_time - last_paint_time;
            last_paint_time = paint_time;

            _this.x += dt * speed * Math.cos(_this.direction);
            _this.y += dt * speed * Math.sin(_this.direction);
        };

        this.paint = (history_context) => {
            // if we're in a jump we do not draw to the history layer
            if (in_jump) return;

            //history_context.save();
            history_context.beginPath();
            history_context.fillStyle = color;
            history_context.arc(_this.x, _this.y, size, 0, Math.PI * 2, true);
            /*history_context.translate(x, y);
            history_context.rotate(direction);
            history_context.fillRect(_this.x - 5, _this.y - 1, 10, 2);*/
            history_context.fill();
            //history_context.restore();
        };

        this.paint_current_pos = (position_context) => {
            // paint filled circle at current position
            position_context.beginPath();
            position_context.fillStyle = color;
            position_context.arc(_this.x, _this.y, size, 0, Math.PI * 2, true);
            position_context.fill();
        };
    };

    let app = {};

    (() => {
        let history_layer = document.getElementById('history_layer');
        let history_ctx = history_layer.getContext('2d');

        let position_layer = document.getElementById('position_layer');
        let position_ctx = position_layer.getContext('2d');

        let history = new History(history_layer.width, history_layer.height);

        let lr = {'left': 'ArrowLeft', 'right': 'ArrowRight'};
        let zx = {'left': 'z', 'right': 'x'};
        let nm = {'left': 'n', 'right': 'm'};

        let worms = [
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#ff5600', history, lr),
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#0f8', history, zx),
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#05f', history, nm),
        ];

        let loop = () => {
            // clear position layer
            position_ctx.clearRect(
                0, 0, position_layer.width, position_layer.height);

            worms.forEach((worm) => {
                if (Math.random() > .995)
                    worm.start_jump();
                worm.travel();
                worm.paint(history_ctx);
                worm.paint_current_pos(position_ctx);
            });
            window.requestAnimationFrame(loop);
        };

        window.requestAnimationFrame(loop);
    })();
</script>
