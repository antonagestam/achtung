<style>
    body {
        background: black;
    }

    canvas {
        background: #111;
    }
</style>

<canvas id="canvas" width="1024" height="800">
</canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>

<script>
    "use strict";
    // * utils *

    function partial(fn) {
        let slice = Array.prototype.slice;
        // Convert arguments object to an array, removing the first argument.
        let args = slice.call(arguments, 1);
        return function() {
            // Invoke the originally-specified function, passing in all originally-
            // specified arguments, followed by any just-specified arguments.
            return fn.apply(this, args.concat(slice.call(arguments, 0)));
        };
    }

    function distance(ax, ay, bx, by) {
        console.log(ax, ay, bx, by);
        return Math.sqrt((ax - bx) ** 2 + (ay - by) ** 2);
    }

    function zeroes(x, y) {
        return new Array(x).fill().map(() => new Array(y).fill(0));
    }

    let get_key_state = (() => {
        let state = {};

        $('body').on('keydown', (e) => {
            state[e.key] = true;
        }).on('keyup', (e) => {
            state[e.key] = false;
        });

        return (key) => state.hasOwnProperty(key) && state[key] || false;
    })();

    let random_direction = () => Math.random() * 2 * Math.PI;
    let random_within = (min, max) => Math.random() * (max-min) + min;
</script>

<script>
    "use strict";

    let History = function (x, y) {
        let grid = zeroes(x, y);

        console.log('width', grid.length);
        console.log('height', grid[0].length);

        this.push = function (x, y) {
            // Checks whether surrounding pixels have been visited and kills
            // the worm with an exception if any of them have. Otherwise pushes
            // the current position to history.
            if (grid[x][y]
                    || grid[x-1][y]
                    || grid[x+1][y]
                    || grid[x][y-1]
                    || grid[x][y+1]) {
                throw Error("you have already been here");
            }
            grid[x][y] = 1;
        };
    };

    let JUMP_LENGTH = 5;

    let Worm = function (x, y, direction, color, history, keys) {
        let _this = this;
        let speed = 2.3;
        let turn_speed = .04;
        let dead = false;
        let size = 4;
        this.x = x;
        this.y = y;
        this.direction = direction;
        let in_jump = false;
        let jump_count = 0;

        let get_x = () => Math.round(this.x);
        let get_y = () => Math.round(this.y);

        let die = () => {
            speed = 0;
            dead = true;
        };

        let pushHistory = () => {
            try {
                history.push(get_x(), get_y());
            } catch (e) {
                console.log(e);
                die();
            }
        };

        this.start_jump = () => {
            in_jump = true;
            jump_count = 0;
        };

        this.jump = () => {
            jump_count += 1;
            if (jump_count > JUMP_LENGTH)
                in_jump = false;
        };

        this.travel = () => {
            if (dead) return;

            this.jump();

            if (!in_jump) pushHistory();

            if (get_key_state(keys.left)) {
                _this.direction -= turn_speed;
            } else if (get_key_state(keys.right)) {
                _this.direction += turn_speed;
            }
            _this.x += speed * Math.cos(_this.direction);
            _this.y += speed * Math.sin(_this.direction);
        };

        this.paint = (context) => {
            if (in_jump) return;
            //context.save();
            context.beginPath();
            context.fillStyle = color;
            context.arc(_this.x, _this.y, size, 0, Math.PI * 2, true);
            /*context.translate(x, y);
            context.rotate(direction);
            context.fillRect(_this.x - 5, _this.y - 1, 10, 2);*/
            context.fill();
            //context.restore();
        };
    };

    let app = {};

    (() => {
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');

        let history = new History(canvas.width, canvas.height);

        let lr = {'left': 'ArrowLeft', 'right': 'ArrowRight'};
        let zx = {'left': 'z', 'right': 'x'};
        let nm = {'left': 'n', 'right': 'm'};

        let worms = [
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#ff5600', history, lr),
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#0f8', history, zx),
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#05f', history, nm),
        ];

        let loop = () => {
            worms.forEach((worm) => {
                if (Math.random() > .99)
                    worm.start_jump();
                worm.travel();
                worm.paint(ctx);
            });
            window.requestAnimationFrame(loop);
        };

        window.requestAnimationFrame(loop);
    })();
</script>
