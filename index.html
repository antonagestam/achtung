<style>
    body {
        background: black;
    }

    canvas {
        background: #111;
    }
</style>

<canvas id="canvas" width="1024" height="800">
</canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>

<script>
    "use strict";
    // * utils *
    function zeroes(x, y) {
        return new Array(x).fill().map(() => new Array(y).fill(0));
    }

    let get_key_state = (() => {
        let state = {};

        $('body').on('keydown', (e) => {
            state[e.key] = true;
        }).on('keyup', (e) => {
            state[e.key] = false;
        });

        return (key) => state.hasOwnProperty(key) && state[key] || false;
    })();

    let random_direction = () => Math.random() * 2 * Math.PI;
    let random_within = (min, max) => Math.random() * (max-min) + min;
</script>

<script>
    "use strict";

    let History = function (x, y) {
        let grid = zeroes(x, y);

        console.log('width', grid.length);
        console.log('height', grid[0].length);

        this.push = function (x, y) {
            // Checks whether surrounding pixels have been visited and kills
            // the worm with an exception if any of them have. Otherwise pushes
            // the current position to history.
            if (grid[x][y]
                    || grid[x-1][y]
                    || grid[x+1][y]
                    || grid[x][y-1]
                    || grid[x][y+1]) {
                throw Error("you have already been here");
            }
            grid[x][y] = 1;
        };
    };

    let JUMP_LENGTH = 5;

    let Worm = function (x, y, direction, color, history, keys) {
        let _this = this;
        let speed = .14;
        let turn_speed = .04;
        let dead = false;
        let size = 4;
        this.x = x;
        this.y = y;
        this.direction = direction;
        let in_jump = false;
        let jump_count = 0;
        let last_paint_time;
        let previous_x, previous_y;

        let get_x = () => Math.round(this.x);
        let get_y = () => Math.round(this.y);

        let die = () => {
            speed = 0;
            dead = true;
        };

        let pushHistory = () => {
            try {
                history.push(get_x(), get_y());
            } catch (e) {
                // die if we're not in the same position as in the previous loop
                if (previous_x !== get_x() || previous_y !== get_y()) {
                    console.log(e);
                    die();
                }
            }
            previous_x = get_x();
            previous_y = get_y();
        };

        this.start_jump = () => {
            in_jump = true;
            jump_count = 0;
        };

        this.jump = () => {
            jump_count += 1;
            if (jump_count > JUMP_LENGTH)
                in_jump = false;
        };

        this.travel = () => {
            // don't move if we're dead
            if (dead) return;

            if (last_paint_time === undefined)
                last_paint_time = performance.now();

            // if we're in a jump, count the number of loops,
            // otherwise push the position to history
            if (!in_jump) pushHistory();
            else this.jump();

            if (get_key_state(keys.left))
                _this.direction -= turn_speed;
            else if (get_key_state(keys.right))
                _this.direction += turn_speed;

            let paint_time = performance.now();
            let dt = paint_time - last_paint_time;
            console.log('dt', dt);
            last_paint_time = paint_time;

            _this.x += dt * speed * Math.cos(_this.direction);
            _this.y += dt * speed * Math.sin(_this.direction);
        };

        this.paint = (context) => {
            if (in_jump) return;
            //context.save();
            context.beginPath();
            context.fillStyle = color;
            context.arc(_this.x, _this.y, size, 0, Math.PI * 2, true);
            /*context.translate(x, y);
            context.rotate(direction);
            context.fillRect(_this.x - 5, _this.y - 1, 10, 2);*/
            context.fill();
            //context.restore();
        };
    };

    let app = {};

    (() => {
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');

        let history = new History(canvas.width, canvas.height);

        let lr = {'left': 'ArrowLeft', 'right': 'ArrowRight'};
        let zx = {'left': 'z', 'right': 'x'};
        let nm = {'left': 'n', 'right': 'm'};

        let worms = [
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#ff5600', history, lr),
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#0f8', history, zx),
            new Worm(
                random_within(200, 600), // initial x
                random_within(200, 400), // initial y
                random_direction(), // initial direction
                '#05f', history, nm),
        ];

        let loop = () => {
            worms.forEach((worm) => {
                //console.log(worm.x, worm.y);
                if (Math.random() > .99)
                    worm.start_jump();
                worm.travel();
                worm.paint(ctx);
            });
            window.requestAnimationFrame(loop);
        };

        window.requestAnimationFrame(loop);
    })();
</script>
